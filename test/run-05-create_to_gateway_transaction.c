#include <ccan/asort/asort.h>
#include <time.h>
#include <assert.h>

static time_t fake_time;
static time_t my_time(time_t *p)
{
	if (p)
		*p = fake_time;
	return fake_time;
}

#define main generate_main
#define time my_time

#include "../timestamp.c"
#include "../generate.c"
#undef main
#undef time
#include "helper_key.h"
#include "helper_gateway_key.h"
#include "../hash_block.c"
#include "../shadouble.c"
#include "../difficulty.c"
#include "../merkle_txs.c"
#include "../merkle_recurse.c"
#include "../merkle_hashes.c"
#include "../tx_cmp.c"
#include "../marshal.c"
#include "../hash_tx.c"
#include "../create_tx.c"
#include "../check_block.c"
#include "../block.c"
#include "../block_shard.c"
#include "../prev_txhashes.c"
#include "../minimal_log.c"
#include "../signature.c"
#include "../txhash.c"
#include "../inputhash.c"
#include "../shard.c"
#include "../chain.c"
#include "../check_tx.c"
#include "../features.c"
#include "../tal_packet.c"
#include "../gateways.c"
#include "../state.c"
#include "../pseudorand.c"
#include "../create_refs.c"
#include "../tx.c"
#include "../proof.c"
#include "../tx_in_hashes.c"
#include "easy_genesis.c"

/* AUTOGENERATED MOCKS START */
/* Generated stub for block_to_pending */
void block_to_pending(struct state *state, const struct block *block)
{ fprintf(stderr, "block_to_pending called!\n"); abort(); }
/* Generated stub for check_tx_refs */
enum ref_ecode check_tx_refs(struct state *state,
			     const struct block *block,
			     const union protocol_tx *tx,
			     const struct protocol_input_ref *refs,
			     unsigned int *bad_ref,
			     struct block **block_referred_to)
{ fprintf(stderr, "check_tx_refs called!\n"); abort(); }
/* Generated stub for complain_bad_amount */
void complain_bad_amount(struct state *state,
			 struct block *block,
			 const struct protocol_proof *proof,
			 const union protocol_tx *tx,
			 const struct protocol_input_ref *refs,
			 const union protocol_tx *intx[])
{ fprintf(stderr, "complain_bad_amount called!\n"); abort(); }
/* Generated stub for complain_bad_claim */
void complain_bad_claim(struct state *state,
			struct block *claim_block,
			const struct protocol_proof *claim_proof,
			const union protocol_tx *claim_tx,
			const struct protocol_input_ref *claim_refs,
			const struct block *reward_block,
			u16 reward_shard, u8 reward_txoff)
{ fprintf(stderr, "complain_bad_claim called!\n"); abort(); }
/* Generated stub for complain_bad_input */
void complain_bad_input(struct state *state,
			struct block *block,
			const struct protocol_proof *proof,
			const union protocol_tx *tx,
			const struct protocol_input_ref *refs,
			unsigned int bad_input,
			const union protocol_tx *intx)
{ fprintf(stderr, "complain_bad_input called!\n"); abort(); }
/* Generated stub for complain_bad_input_ref */
void complain_bad_input_ref(struct state *state,
			    struct block *block,
			    const struct protocol_proof *proof,
			    const union protocol_tx *tx,
			    const struct protocol_input_ref *refs,
			    unsigned int bad_refnum,
			    const struct block *block_referred_to)
{ fprintf(stderr, "complain_bad_input_ref called!\n"); abort(); }
/* Generated stub for complain_bad_prev_txhashes */
void complain_bad_prev_txhashes(struct state *state,
				struct block *block,
				const struct block *bad_prev,
				u16 bad_prev_shard)
{ fprintf(stderr, "complain_bad_prev_txhashes called!\n"); abort(); }
/* Generated stub for complain_doublespend */
void complain_doublespend(struct state *state,
			  struct block *block1,
			  u32 input1,
			  const struct protocol_proof *proof1,
			  const union protocol_tx *tx1,
			  const struct protocol_input_ref *refs1,
			  struct block *block2,
			  u32 input2,
			  const struct protocol_proof *proof2,
			  const union protocol_tx *tx2,
			  const struct protocol_input_ref *refs2)
{ fprintf(stderr, "complain_doublespend called!\n"); abort(); }
/* Generated stub for log_to_file */
void log_to_file(int fd, const struct log *log)
{ fprintf(stderr, "log_to_file called!\n"); abort(); }
/* Generated stub for logv */
void logv(struct log *log, enum log_level level, const char *fmt, va_list ap)
{ fprintf(stderr, "logv called!\n"); abort(); }
/* Generated stub for reward_amount */
u32 reward_amount(const struct block *reward_block,
		  const union protocol_tx *tx)
{ fprintf(stderr, "reward_amount called!\n"); abort(); }
/* Generated stub for reward_get_tx */
bool reward_get_tx(struct state *state,
		   const struct block *reward_block,
		   const struct block *claim_block,
		   u16 *shardnum, u8 *txoff)
{ fprintf(stderr, "reward_get_tx called!\n"); abort(); }
/* Generated stub for todo_add_get_tx */
void todo_add_get_tx(struct state *state,
		     const struct protocol_double_sha *tx)
{ fprintf(stderr, "todo_add_get_tx called!\n"); abort(); }
/* Generated stub for todo_add_get_tx_in_block */
void todo_add_get_tx_in_block(struct state *state,
			      const struct protocol_double_sha *block,
			      u16 shardnum, u8 txoff)
{ fprintf(stderr, "todo_add_get_tx_in_block called!\n"); abort(); }
/* Generated stub for todo_forget_about_block */
void todo_forget_about_block(struct state *state,
			     const struct protocol_double_sha *block)
{ fprintf(stderr, "todo_forget_about_block called!\n"); abort(); }
/* Generated stub for wake_peers */
void wake_peers(struct state *state)
{ fprintf(stderr, "wake_peers called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

void send_tx_in_block_to_peers(struct state *state, const struct peer *exclude,
			       struct block *block, u16 shard, u8 txoff)
{
}

void save_block(struct state *state, struct block *new)
{
}

void save_tx(struct state *state, struct block *block, u16 shard, u8 txoff)
{
}

void todo_add_get_shard(struct state *state,
			const struct protocol_double_sha *block,
			u16 shardnum)
{
}

struct log *new_log(const tal_t *ctx,
		    const struct log *parent,
		    const char *prefix,
		    enum log_level printlevel, size_t max_mem)
{
	return NULL;
}

struct pending_block *new_pending_block(struct state *state)
{
	return talz(state, struct pending_block);
}

int main(int argc, char *argv[])
{
	struct state *s;
	struct working_block *w, *w2, *w3;
	unsigned int i;
	union protocol_tx *t;
	struct protocol_gateway_payment payment;
	struct block *b, *b2, *b3, *prev;
	struct block_shard *shard;
	struct protocol_input inputs[1];
	u8 *prev_txhashes;
	enum protocol_ecode e;
	struct gen_update update;
	struct protocol_input_ref *refs;
	struct protocol_double_sha sha;

	/* We need enough of state to use the real init function here. */
	pseudorand_init();
	s = new_state(true);

	fake_time = le32_to_cpu(genesis_tlr.timestamp) + 1;

	/* Create a block with a gateway tx in it. */
	prev_txhashes = make_prev_txhashes(s, &genesis, helper_addr(1));
	w = new_working_block(s, 0x1ffffff0,
			      prev_txhashes, tal_count(prev_txhashes),
			      le32_to_cpu(genesis.hdr->depth) + 1,
			      next_shard_order(&genesis),
			      &genesis.sha, helper_addr(1));

	payment.send_amount = cpu_to_le32(1000);
	payment.output_addr = *helper_addr(0);
	t = create_from_gateway_tx(s, helper_gateway_public_key(),
				   1, &payment, true, helper_gateway_key(s));
	/* Gateway txs have empty refs, so this gives 0-len array. */
	refs = create_refs(s, &genesis, t, 1);

	update.shard = shard_of_tx(t, next_shard_order(&genesis));
	update.txoff = 0;
	update.features = 0;
	update.unused = 0;
	hash_tx_and_refs(t, refs, &update.hashes);
	assert(add_tx(w, &update));
	for (i = 0; !solve_block(w); i++);

	e = check_block_header(s, &w->hdr, w->shard_nums, w->merkles,
			       w->prev_txhashes, &w->tailer, &prev, &sha);
	assert(e == PROTOCOL_ECODE_NONE);
	assert(prev == &genesis);

	b = block_add(s, prev, &sha,
		      &w->hdr, w->shard_nums, w->merkles,
		      w->prev_txhashes, &w->tailer);

	/* This is a NOOP, so should succeed. */
	assert(check_prev_txhashes(s, b, NULL, NULL));

	/* Put the single tx into a shard. */
	shard = new_block_shard(s, update.shard, 1);
	b->shard[shard->shardnum] = shard;
	put_tx_in_shard(s, NULL, b, shard, 0, txptr_with_ref(shard, t, refs));

	/* This should all be correct. */
	check_block_shard(s, b, shard);
	assert(block_all_known(b));

	/* Solve third block, with a normal tx in it. */
	prev_txhashes = make_prev_txhashes(s, b, helper_addr(1));

	fake_time++;
	w2 = new_working_block(s, 0x1ffffff0,
			       prev_txhashes, num_prev_txhashes(b),
			       le32_to_cpu(b->hdr->depth) + 1,
			       next_shard_order(b),
			       &b->sha, helper_addr(1));

	/* We are going to spend over half the gateway tx. */
	hash_tx(t, &inputs[0].input);
	inputs[0].output = 0;
	inputs[0].unused = 0;

	assert(PROTOCOL_FEE(1000) == 3);
	t = create_normal_tx(s, helper_addr(1),
			     600, 397, 1, true, inputs,
			     helper_private_key(s, 0));
	assert(t->normal.change_amount == 397);
	assert(num_inputs(t) == 1);

	/* This should create a reference back to the gateway tx */
	refs = create_refs(s, b, t, 1);
	assert(tal_count(refs) == num_inputs(t));
	assert(refs[0].blocks_ago == cpu_to_le32(1));
	assert(refs[0].shard == cpu_to_le16(update.shard));
	assert(refs[0].txoff == 0);
	assert(refs[0].unused == 0);

	update.shard = shard_of_tx(t, next_shard_order(b));
	update.txoff = 0;
	update.features = 0;
	update.unused = 0;
	hash_tx_and_refs(t, refs, &update.hashes);
	assert(add_tx(w2, &update));
	for (i = 0; !solve_block(w2); i++);

	e = check_block_header(s, &w2->hdr, w2->shard_nums, w2->merkles,
			       w2->prev_txhashes, &w2->tailer, &prev, &sha);
	assert(e == PROTOCOL_ECODE_NONE);
	assert(prev == b);

	b2 = block_add(s, prev, &sha,
		       &w2->hdr, w2->shard_nums, w2->merkles,
		       w2->prev_txhashes, &w2->tailer);

	/* This should be correct. */
	assert(check_prev_txhashes(s, b2, NULL, NULL));

	/* Put the single tx into a shard. */
	shard = new_block_shard(s, update.shard, 1);
	b2->shard[shard->shardnum] = shard;
	put_tx_in_shard(s, NULL, b2, shard, 0, txptr_with_ref(shard, t, refs));

	/* Should work */
	check_block_shard(s, b2, shard);

	b2->shard[shard->shardnum] = shard;
	assert(block_all_known(b2));

	/* Now, return 3/4 of change to the gateway, using normal tx. */
	prev_txhashes = make_prev_txhashes(s, b2, helper_addr(1));

	fake_time++;
	w3 = new_working_block(s, 0x1ffffff0,
			       prev_txhashes, num_prev_txhashes(b2),
			       le32_to_cpu(b2->hdr->depth) + 1,
			       next_shard_order(b2),
			       &b2->sha, helper_addr(1));

	hash_tx(t, &inputs[0].input);
	inputs[0].output = 1;
	inputs[0].unused = 0;

	assert(PROTOCOL_FEE(397) == 2);
	t = create_to_gateway_tx(s, helper_addr(1),
				 300, 95, 1, true, inputs,
				 helper_private_key(s, 0));
	assert(t->to_gateway.change_amount == 95);
	assert(num_inputs(t) == 1);

	/* This should create a reference back to the normal tx */
	refs = create_refs(s, b2, t, 1);
	assert(tal_count(refs) == num_inputs(t));
	assert(refs[0].blocks_ago == cpu_to_le32(1));
	assert(refs[0].shard == cpu_to_le16(update.shard));
	assert(refs[0].txoff == 0);
	assert(refs[0].unused == 0);

	update.shard = shard_of_tx(t, next_shard_order(b2));
	update.txoff = 0;
	update.features = 0;
	update.unused = 0;
	hash_tx_and_refs(t, refs, &update.hashes);
	assert(add_tx(w3, &update));
	for (i = 0; !solve_block(w3); i++);

	e = check_block_header(s, &w3->hdr, w3->shard_nums, w3->merkles,
			       w3->prev_txhashes, &w3->tailer, &prev, &sha);
	assert(e == PROTOCOL_ECODE_NONE);
	assert(prev == b2);

	b3 = block_add(s, prev, &sha,
		       &w3->hdr, w3->shard_nums, w3->merkles,
		       w3->prev_txhashes, &w3->tailer);

	/* This should be correct. */
	assert(check_prev_txhashes(s, b3, NULL, NULL));

	/* Put the single tx into a shard. */
	shard = new_block_shard(s, update.shard, 1);
	b3->shard[shard->shardnum] = shard;
	put_tx_in_shard(s, NULL, b3, shard, 0, txptr_with_ref(shard, t, refs));

	/* Should work */
	check_block_shard(s, b3, shard);

	b3->shard[shard->shardnum] = shard;
	assert(block_all_known(b3));

	tal_free(s);
	return 0;
}
