#include <ccan/time/time.h>

/* Override time_now in timestamp.h: make sure it always progresses. */
static time_t fake_time;
static struct timeabs fake_time_now(void)
{
	struct timeabs now;

	now.ts.tv_sec = fake_time++;
	now.ts.tv_nsec = 0;

	return now;
}
#undef time_now
#define time_now fake_time_now

#include "../chain.c"
#include "../state.c"
#include "../timeout.c"
#include "../block.c"
#include "../pseudorand.c"
#include "../base58.c"
#include "../log.c"
#include "../log_helper.c"
#include "../pkt_names.c"
#include "../difficulty.c"
#include "../block_shard.c"
#include "../pending.c"
#include "../prev_txhashes.c"
#include "../prev_blocks.c"
#include "../check_block.c"
#include "../create_tx.c"
#include "../marshal.c"
#include "../inputhash.c"
#include "../tx_in_hashes.c"
#include "../shadouble.c"
#include "../merkle_hashes.c"
#include "../merkle_recurse.c"
#include "../merkle_txs.c"
#include "../signature.c"
#include "../hash_tx.c"
#include "../txhash.c"
#include "../check_tx.c"
#include "../shard.c"
#include "../create_refs.c"
#include "../tal_packet.c"
#include "../recv_block.c"
#include "../ecode_names.c"
#include "../hash_block.c"
#include "../timestamp.c"
#include "../features.c"
#include "../gateways.c"
#include "../tx.c"
#include "../horizon.c"
#include "easy_genesis.c"
#include "helper_key.h"
#include "helper_gateway_key.h"
#include <ccan/strmap/strmap.h>
#include <ccan/tal/str/str.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for add_detached_block */
void add_detached_block(struct state *state,
			const tal_t *pkt_ctx,
			const struct protocol_block_id *sha,
			const struct block_info *bi)
{ fprintf(stderr, "add_detached_block called!\n"); abort(); }
/* Generated stub for check_proof */
bool check_proof(const struct protocol_proof *proof,
		 const struct block *b,
		 const union protocol_tx *tx,
		 const struct protocol_input_ref *refs)
{ fprintf(stderr, "check_proof called!\n"); abort(); }
/* Generated stub for check_tx_refs */
enum ref_ecode check_tx_refs(struct state *state,
			     const struct block *block,
			     const union protocol_tx *tx,
			     const struct protocol_input_ref *refs,
			     unsigned int *bad_ref,
			     struct block **block_referred_to)
{ fprintf(stderr, "check_tx_refs called!\n"); abort(); }
/* Generated stub for complain_bad_amount */
void complain_bad_amount(struct state *state,
			 struct block *block,
			 const struct protocol_proof *proof,
			 const union protocol_tx *tx,
			 const struct protocol_input_ref *refs,
			 const union protocol_tx *intx[])
{ fprintf(stderr, "complain_bad_amount called!\n"); abort(); }
/* Generated stub for complain_bad_claim */
void complain_bad_claim(struct state *state,
			struct block *claim_block,
			const struct protocol_proof *claim_proof,
			const union protocol_tx *claim_tx,
			const struct protocol_input_ref *claim_refs,
			const struct block *reward_block,
			u16 reward_shard, u8 reward_txoff)
{ fprintf(stderr, "complain_bad_claim called!\n"); abort(); }
/* Generated stub for complain_bad_input */
void complain_bad_input(struct state *state,
			struct block *block,
			const struct protocol_proof *proof,
			const union protocol_tx *tx,
			const struct protocol_input_ref *refs,
			unsigned int bad_input,
			const union protocol_tx *intx)
{ fprintf(stderr, "complain_bad_input called!\n"); abort(); }
/* Generated stub for complain_bad_input_ref */
void complain_bad_input_ref(struct state *state,
			    struct block *block,
			    const struct protocol_proof *proof,
			    const union protocol_tx *tx,
			    const struct protocol_input_ref *refs,
			    unsigned int bad_refnum,
			    const struct block *block_referred_to)
{ fprintf(stderr, "complain_bad_input_ref called!\n"); abort(); }
/* Generated stub for complain_bad_prev_txhashes */
void complain_bad_prev_txhashes(struct state *state,
				struct block *block,
				const struct block *bad_prev,
				u16 bad_prev_shard)
{ fprintf(stderr, "complain_bad_prev_txhashes called!\n"); abort(); }
/* Generated stub for complain_doublespend */
void complain_doublespend(struct state *state,
			  struct block *block1,
			  u32 input1,
			  const struct protocol_proof *proof1,
			  const union protocol_tx *tx1,
			  const struct protocol_input_ref *refs1,
			  struct block *block2,
			  u32 input2,
			  const struct protocol_proof *proof2,
			  const union protocol_tx *tx2,
			  const struct protocol_input_ref *refs2)
{ fprintf(stderr, "complain_doublespend called!\n"); abort(); }
/* Generated stub for complain_misorder */
void complain_misorder(struct state *state,
		       struct block *block,
		       const struct protocol_proof *proof,
		       const union protocol_tx *tx,
		       const struct protocol_input_ref *refs,
		       unsigned int conflict_txoff)
{ fprintf(stderr, "complain_misorder called!\n"); abort(); }
/* Generated stub for create_proof */
void create_proof(struct protocol_proof *proof,
		  const struct block *block, u16 shard, u8 txoff)
{ fprintf(stderr, "create_proof called!\n"); abort(); }
/* Generated stub for from_hex */
bool from_hex(const char *str, size_t slen, void *buf, size_t bufsize)
{ fprintf(stderr, "from_hex called!\n"); abort(); }
/* Generated stub for have_detached_block */
bool have_detached_block(const struct state *state, 
			 const struct protocol_block_id *sha)
{ fprintf(stderr, "have_detached_block called!\n"); abort(); }
/* Could not find declaration for helper_addr */
/* Could not find declaration for helper_gateway_key */
/* Could not find declaration for helper_gateway_public_key */
/* Could not find declaration for helper_private_key */
/* Generated stub for json_add_address */
void json_add_address(struct json_result *result, const char *fieldname,
		      bool test_net,  const struct protocol_address *addr)
{ fprintf(stderr, "json_add_address called!\n"); abort(); }
/* Generated stub for json_add_block_id */
void json_add_block_id(struct json_result *result, const char *fieldname,
		       const struct protocol_block_id *id)
{ fprintf(stderr, "json_add_block_id called!\n"); abort(); }
/* Generated stub for json_add_double_sha */
void json_add_double_sha(struct json_result *result, const char *fieldname,
			 const struct protocol_double_sha *sha)
{ fprintf(stderr, "json_add_double_sha called!\n"); abort(); }
/* Generated stub for json_add_hex */
void json_add_hex(struct json_result *result, const char *fieldname,
		  const void *data, size_t len)
{ fprintf(stderr, "json_add_hex called!\n"); abort(); }
/* Generated stub for json_add_num */
void json_add_num(struct json_result *result, const char *fieldname,
		  unsigned int value)
{ fprintf(stderr, "json_add_num called!\n"); abort(); }
/* Generated stub for json_add_tx_id */
void json_add_tx_id(struct json_result *result, const char *fieldname,
		    const struct protocol_tx_id *id)
{ fprintf(stderr, "json_add_tx_id called!\n"); abort(); }
/* Generated stub for json_array_end */
void json_array_end(struct json_result *ptr)
{ fprintf(stderr, "json_array_end called!\n"); abort(); }
/* Generated stub for json_array_start */
void json_array_start(struct json_result *ptr, const char *fieldname)
{ fprintf(stderr, "json_array_start called!\n"); abort(); }
/* Generated stub for json_get_params */
void json_get_params(const char *buffer, const jsmntok_t param[], ...)
{ fprintf(stderr, "json_get_params called!\n"); abort(); }
/* Generated stub for json_object_end */
void json_object_end(struct json_result *ptr)
{ fprintf(stderr, "json_object_end called!\n"); abort(); }
/* Generated stub for json_object_start */
void json_object_start(struct json_result *ptr, const char *fieldname)
{ fprintf(stderr, "json_object_start called!\n"); abort(); }
/* Generated stub for json_tok_contents */
const char *json_tok_contents(const char *buffer, const jsmntok_t *t)
{ fprintf(stderr, "json_tok_contents called!\n"); abort(); }
/* Generated stub for json_tok_len */
int json_tok_len(const jsmntok_t *t)
{ fprintf(stderr, "json_tok_len called!\n"); abort(); }
/* Generated stub for json_tok_number */
bool json_tok_number(const char *buffer, const jsmntok_t *tok,
		     unsigned int *num)
{ fprintf(stderr, "json_tok_number called!\n"); abort(); }
/* Generated stub for refresh_peer_cache */
void refresh_peer_cache(struct state *state)
{ fprintf(stderr, "refresh_peer_cache called!\n"); abort(); }
/* Generated stub for reward_amount */
u32 reward_amount(const struct block *reward_block,
		  const union protocol_tx *tx)
{ fprintf(stderr, "reward_amount called!\n"); abort(); }
/* Generated stub for reward_get_tx */
bool reward_get_tx(struct state *state,
		   const struct block *reward_block,
		   const struct block *claim_block,
		   u16 *shardnum, u8 *txoff)
{ fprintf(stderr, "reward_get_tx called!\n"); abort(); }
/* Generated stub for todo_add_get_block */
void todo_add_get_block(struct state *state,
			const struct protocol_block_id *block)
{ fprintf(stderr, "todo_add_get_block called!\n"); abort(); }
/* Generated stub for todo_add_get_children */
void todo_add_get_children(struct state *state,
			   const struct protocol_block_id *block)
{ fprintf(stderr, "todo_add_get_children called!\n"); abort(); }
/* Generated stub for todo_add_get_shard */
void todo_add_get_shard(struct state *state,
			const struct protocol_block_id *block,
			u16 shardnum)
{ fprintf(stderr, "todo_add_get_shard called!\n"); abort(); }
/* Generated stub for todo_add_get_tx */
void todo_add_get_tx(struct state *state, const struct protocol_tx_id *tx)
{ fprintf(stderr, "todo_add_get_tx called!\n"); abort(); }
/* Generated stub for todo_add_get_tx_in_block */
void todo_add_get_tx_in_block(struct state *state,
			      const struct protocol_block_id *block,
			      u16 shardnum, u8 txoff)
{ fprintf(stderr, "todo_add_get_tx_in_block called!\n"); abort(); }
/* Generated stub for todo_add_get_txmap */
void todo_add_get_txmap(struct state *state,
			const struct protocol_block_id *block,
			u16 shardnum)
{ fprintf(stderr, "todo_add_get_txmap called!\n"); abort(); }
/* Generated stub for todo_done_get_block */
void todo_done_get_block(struct peer *peer,
			 const struct protocol_block_id *block,
			 bool success)
{ fprintf(stderr, "todo_done_get_block called!\n"); abort(); }
/* Generated stub for todo_done_get_shard */
void todo_done_get_shard(struct peer *peer,
			 const struct protocol_block_id *block,
			 u16 shardnum, bool success)
{ fprintf(stderr, "todo_done_get_shard called!\n"); abort(); }
/* Generated stub for todo_forget_about_block */
void todo_forget_about_block(struct state *state,
			     const struct protocol_block_id *block)
{ fprintf(stderr, "todo_forget_about_block called!\n"); abort(); }
/* Generated stub for todo_for_peer */
void todo_for_peer(struct peer *peer, void *pkt)
{ fprintf(stderr, "todo_for_peer called!\n"); abort(); }
/* Generated stub for to_hex */
char *to_hex(const tal_t *ctx, const void *buf, size_t bufsize)
{ fprintf(stderr, "to_hex called!\n"); abort(); }
/* Generated stub for to_hex_direct */
size_t to_hex_direct(char *dest, size_t destlen,
		     const void *buf, size_t bufsize)
{ fprintf(stderr, "to_hex_direct called!\n"); abort(); }
/* Generated stub for tx_cmp */
int tx_cmp(const union protocol_tx *a, const union protocol_tx *b)
{ fprintf(stderr, "tx_cmp called!\n"); abort(); }
/* Generated stub for wake_peers */
void wake_peers(struct state *state)
{ fprintf(stderr, "wake_peers called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

int generate_main(int argc, char *argv[]);
#define main generate_main
#include "../pettycoin-generate.c"
#undef main

/* Dummy functions */
void save_block(struct state *state, struct block *new)
{
}

void save_tx(struct state *state, struct block *block, u16 shard, u8 txoff)
{
}

void seek_detached_blocks(struct state *state, const struct block *block)
{
}

void send_block_to_peers(struct state *state,
			 struct peer *exclude,
			 const struct block *block)
{
}

void send_tx_in_block_to_peers(struct state *state, const struct peer *exclude,
			       struct block *block, u16 shard, u8 txoff)
{
}

/* Generated stub for restart_generating */
void restart_generating(struct state *state)
{
}


static struct working_block *w;

void tell_generator_new_pending(struct state *state, u32 shard, u32 txoff)
{
	struct pending_tx *t = state->pending->pend[shard][txoff];
	struct gen_update update;

	update.features = t->tx->hdr.features;
	update.shard = shard;
	update.txoff = txoff;
	update.unused = 0;
	hash_tx_and_refs(t->tx, t->refs, &update.hashes);

	assert(add_tx(w, &update));
}

static const struct block *solve_pending(struct state *state)
{
	unsigned int i;
	struct protocol_pkt_shard **shard_pkt;
	struct protocol_pkt_block *block_pkt;

	/* Now solve that block. */
	for (i = 0; !solve_block(w); i++);

	/* Marshal like they expect, and receive it. */
	block_pkt = marshal_block(w, &w->bi);
	shard_pkt = tal_arr(w, struct protocol_pkt_shard *, w->num_shards);
	for (i = 0; i < w->num_shards; i++)
		shard_pkt[i] = make_shard_pkt(w, i);

	if (!recv_block_from_generator(state, state->log, block_pkt, shard_pkt))
		abort();

	/* Get block we just created. */
	assert(state->longest_chains[0] == state->preferred_chain);
	assert(state->longest_knowns[0] == state->preferred_chain);
	return state->preferred_chain;
}

static u32 num_txs(const struct block *b)
{
	unsigned int i;
	u32 total = 0;

	for (i = 0; i < block_num_shards(&b->bi); i++)
		total += block_num_txs(&b->bi, i);
	return total;
}

static void dump_inputhash(struct state *state, struct inputhash *inputhash)
{
	struct inputhash_elem *ie;
	struct inputhash_iter it;

	log_unusual(state->log, "Input hash start:\n");
	for (ie = inputhash_first(inputhash, &it);
	     ie;
	     ie = inputhash_next(inputhash, &it)) {
		log_unusual(state->log, "  Tx ");
		log_add_struct(state->log, struct protocol_tx_id,
			       &ie->output.tx);
		log_add(state->log, " output %u used by ",
			ie->output.output_num);
		log_add_struct(state->log, struct protocol_tx_id,
			       &ie->used_by);
	}
	log_unusual(state->log, "Input hash end\n");
}

int main(void)
{
	struct state *state;
	union protocol_tx *t, *t2;
	struct protocol_gateway_payment payment;
	u8 *prev_txhashes;
	enum input_ecode e;
	struct protocol_tx_id txid;
	unsigned int bad_input;
	bool too_old, already_known;
	const struct block *b;
	struct protocol_block_id prevs[PROTOCOL_NUM_PREV_IDS];
	struct protocol_input inputs[1];
	
	pseudorand_init();
	state = new_state(true);

	prev_txhashes = make_prev_txhashes(state, &genesis, helper_addr(1));
	memset(prevs, 0, sizeof(prevs));
	prevs[0] = genesis.sha;
	w = new_working_block(state, block_difficulty(&genesis.bi),
			      prev_txhashes, tal_count(prev_txhashes),
			      block_height(&genesis.bi) + 1,
			      next_shard_order(&genesis),
			      prevs, helper_addr(1));

	/* Create a block with a gateway tx in it. */
	payment.send_amount = cpu_to_le32(1000);
	payment.output_addr = *helper_addr(0);
	t = create_from_gateway_tx(state, helper_gateway_public_key(),
				   1, &payment, false, helper_gateway_key(state));
	hash_tx(t, &txid);
	log_unusual(state->log, "Gateway tx is ");
	log_add_struct(state->log, struct protocol_tx_id, &txid);

	e = add_pending_tx(state, t, &txid, &bad_input,
			   &too_old, &already_known);
	assert(e == ECODE_INPUT_OK);
	assert(!already_known);

	assert(state->pending->num_unknown == 0);
	assert(num_pending_known(state) == 1);

	b = solve_pending(state);

	/* Now we can spend it. */
	prev_txhashes = make_prev_txhashes(state, b, helper_addr(1));
	prevs[0] = b->sha;
	prevs[1] = genesis.sha;
	w = new_working_block(state, block_difficulty(&b->bi),
			      prev_txhashes, tal_count(prev_txhashes),
			      block_height(&b->bi) + 1,
			      next_shard_order(b),
			      prevs, helper_addr(1));

	hash_tx(t, &inputs[0].input);
	inputs[0].output = 0;
	inputs[0].unused = 0;

	t2 = t = create_normal_tx(state, helper_addr(1),
				  500, 500 - PROTOCOL_FEE(500), 1, true, inputs,
				  helper_private_key(state, 0));
	
	hash_tx(t, &txid);
	e = add_pending_tx(state, t, &txid, &bad_input,
			   &too_old, &already_known);
	assert(e == ECODE_INPUT_OK);
	assert(!already_known);
	assert(state->pending->num_unknown == 0);
	assert(num_pending_known(state) == 1);

	log_unusual(state->log, "Normal tx is ");
	log_add_struct(state->log, struct protocol_tx_id, &txid);

	/* Should recognize double spend */
	t = create_normal_tx(state, helper_addr(2),
			     300, 700 - PROTOCOL_FEE(300), 1, true, inputs,
			     helper_private_key(state, 0));
	
	hash_tx(t, &txid);
	e = add_pending_tx(state, t, &txid, &bad_input,
			   &too_old, &already_known);
	assert(e == ECODE_INPUT_DOUBLESPEND);
	assert(!already_known);

	assert(state->pending->num_unknown == 0);
	assert(num_pending_known(state) == 1);

	b = solve_pending(state);
	/* The first should be included. */
	assert(num_txs(b) == 1);

	/* There should be nothing left. */ 
	assert(state->pending->num_unknown == 0);
	assert(num_pending_known(state) == 0);

	/* Now retry double spend. */
	t = create_normal_tx(state, helper_addr(2),
			     300, 700 - PROTOCOL_FEE(300), 1, true, inputs,
			     helper_private_key(state, 0));
	
	hash_tx(t, &txid);
	e = add_pending_tx(state, t, &txid, &bad_input,
			   &too_old, &already_known);
	assert(e == ECODE_INPUT_DOUBLESPEND);
	assert(!too_old);
	assert(!already_known);

	/* Clear inputhash manually. */
	inputhash_del_tx(&state->inputhash, t2);

	dump_inputhash(state, &state->inputhash);
	tal_free(state);
	return 0;
}
