#include "../chain.c"
#include "../state.c"
#include "../timeout.c"
#include "../block.c"
#include "../pseudorand.c"
#include "../minimal_log.c"
#include "../difficulty.c"
#include "../block_shard.c"
#include "../tx.c"
#include "easy_genesis.c"
#include "named_blocks.c"

/* AUTOGENERATED MOCKS START */
/* Generated stub for check_proof */
bool check_proof(const struct protocol_proof *proof,
		 const struct block *b,
		 const union protocol_tx *tx,
		 const struct protocol_input_ref *refs)
{ fprintf(stderr, "check_proof called!\n"); abort(); }
/* Generated stub for check_tx */
enum protocol_ecode check_tx(struct state *state, const union protocol_tx *tx,
			     const struct block *inside_block)
{ fprintf(stderr, "check_tx called!\n"); abort(); }
/* Generated stub for check_tx_inputs */
enum input_ecode check_tx_inputs(struct state *state,
				 const struct block *block,
				 const struct txhash_elem *me,
				 const union protocol_tx *tx,
				 unsigned int *bad_input_num)
{ fprintf(stderr, "check_tx_inputs called!\n"); abort(); }
/* Generated stub for complain_bad_prev_txhashes */
void complain_bad_prev_txhashes(struct state *state,
				struct block *block,
				const struct block *bad_prev,
				u16 bad_prev_shard)
{ fprintf(stderr, "complain_bad_prev_txhashes called!\n"); abort(); }
/* Generated stub for from_hex */
bool from_hex(const char *str, size_t slen, void *buf, size_t bufsize)
{ fprintf(stderr, "from_hex called!\n"); abort(); }
/* Generated stub for hash_tx */
void hash_tx(const union protocol_tx *tx, struct protocol_tx_id *txid)
{ fprintf(stderr, "hash_tx called!\n"); abort(); }
/* Generated stub for hash_tx_and_refs */
void hash_tx_and_refs(const union protocol_tx *tx,
		      const struct protocol_input_ref *refs,
		      struct protocol_txrefhash *txrefhash)
{ fprintf(stderr, "hash_tx_and_refs called!\n"); abort(); }
/* Generated stub for inputhash_hashfn */
size_t inputhash_hashfn(const struct inputhash_key *key)
{ fprintf(stderr, "inputhash_hashfn called!\n"); abort(); }
/* Generated stub for inputhash_keyof */
const struct inputhash_key *inputhash_keyof(const struct inputhash_elem *ie)
{ fprintf(stderr, "inputhash_keyof called!\n"); abort(); }
/* Generated stub for json_add_address */
void json_add_address(struct json_result *result, const char *fieldname,
		      bool test_net,  const struct protocol_address *addr)
{ fprintf(stderr, "json_add_address called!\n"); abort(); }
/* Generated stub for json_add_block_id */
void json_add_block_id(struct json_result *result, const char *fieldname,
		       const struct protocol_block_id *id)
{ fprintf(stderr, "json_add_block_id called!\n"); abort(); }
/* Generated stub for json_add_double_sha */
void json_add_double_sha(struct json_result *result, const char *fieldname,
			 const struct protocol_double_sha *sha)
{ fprintf(stderr, "json_add_double_sha called!\n"); abort(); }
/* Generated stub for json_add_hex */
void json_add_hex(struct json_result *result, const char *fieldname,
		  const void *data, size_t len)
{ fprintf(stderr, "json_add_hex called!\n"); abort(); }
/* Generated stub for json_add_num */
void json_add_num(struct json_result *result, const char *fieldname,
		  unsigned int value)
{ fprintf(stderr, "json_add_num called!\n"); abort(); }
/* Generated stub for json_add_tx_id */
void json_add_tx_id(struct json_result *result, const char *fieldname,
		    const struct protocol_tx_id *id)
{ fprintf(stderr, "json_add_tx_id called!\n"); abort(); }
/* Generated stub for json_array_end */
void json_array_end(struct json_result *ptr)
{ fprintf(stderr, "json_array_end called!\n"); abort(); }
/* Generated stub for json_array_start */
void json_array_start(struct json_result *ptr, const char *fieldname)
{ fprintf(stderr, "json_array_start called!\n"); abort(); }
/* Generated stub for json_get_params */
void json_get_params(const char *buffer, const jsmntok_t param[], ...)
{ fprintf(stderr, "json_get_params called!\n"); abort(); }
/* Generated stub for json_object_end */
void json_object_end(struct json_result *ptr)
{ fprintf(stderr, "json_object_end called!\n"); abort(); }
/* Generated stub for json_object_start */
void json_object_start(struct json_result *ptr, const char *fieldname)
{ fprintf(stderr, "json_object_start called!\n"); abort(); }
/* Generated stub for json_tok_contents */
const char *json_tok_contents(const char *buffer, const jsmntok_t *t)
{ fprintf(stderr, "json_tok_contents called!\n"); abort(); }
/* Generated stub for json_tok_len */
int json_tok_len(const jsmntok_t *t)
{ fprintf(stderr, "json_tok_len called!\n"); abort(); }
/* Generated stub for json_tok_number */
bool json_tok_number(const char *buffer, const jsmntok_t *tok,
		     unsigned int *num)
{ fprintf(stderr, "json_tok_number called!\n"); abort(); }
/* Generated stub for log_to_file */
void log_to_file(int fd, const struct log_record *lr)
{ fprintf(stderr, "log_to_file called!\n"); abort(); }
/* Generated stub for logv */
void logv(struct log *log, enum log_level level, const char *fmt, va_list ap)
{ fprintf(stderr, "logv called!\n"); abort(); }
/* Generated stub for make_prev_blocks */
void make_prev_blocks(const struct block *prev,
		      struct protocol_block_id prevs[PROTOCOL_NUM_PREV_IDS])
{ fprintf(stderr, "make_prev_blocks called!\n"); abort(); }
/* Generated stub for merkle_txs */
void merkle_txs(const struct block_shard *shard,
		struct protocol_double_sha *merkle)
{ fprintf(stderr, "merkle_txs called!\n"); abort(); }
/* Generated stub for refresh_peer_cache */
void refresh_peer_cache(struct state *state)
{ fprintf(stderr, "refresh_peer_cache called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

void block_to_pending(struct state *state, const struct block *block)
{
}

void check_block(struct state *state, const struct block *block, bool all)
{
}

bool check_prev_txhashes(struct state *state, const struct block *block,
			 const struct block **bad_prev,
			 u16 *bad_shard)
{
	return true;
}

void restart_generating(struct state *state)
{
}

void todo_forget_about_block(struct state *state,
			     const struct protocol_block_id *block)
{
}

void wake_peers(struct state *state)
{
}

void save_block(struct state *state, struct block *new)
{
}

struct pending_block *new_pending_block(struct state *state)
{
	return talz(state, struct pending_block);
}

u8 pending_features(const struct block *block)
{
	return 0;
}

void todo_add_get_shard(struct state *state,
			const struct protocol_block_id *block,
			u16 shardnum)
{
}

void seek_detached_blocks(struct state *state, 
			  const struct block *block)
{
}

int main(void)
{
	struct state *state;
	struct protocol_address dummy = { { 0 } };

	pseudorand_init();
	state = new_state(true);

	/* genesis -> block1-0 ... block1-9. */
	create_chain(state, &genesis, "block1",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 10, true);
	assert(strmap_get(&blockmap, "block1-0")->known_in_a_row == 2);
	assert(strmap_get(&blockmap, "block1-1")->known_in_a_row == 3);
	assert(strmap_get(&blockmap, "block1-2")->known_in_a_row == 4);
	assert(strmap_get(&blockmap, "block1-3")->known_in_a_row == 5);
	assert(strmap_get(&blockmap, "block1-4")->known_in_a_row == 6);
	assert(strmap_get(&blockmap, "block1-5")->known_in_a_row == 7);
	assert(strmap_get(&blockmap, "block1-6")->known_in_a_row == 8);
	assert(strmap_get(&blockmap, "block1-7")->known_in_a_row == 9);
	assert(strmap_get(&blockmap, "block1-8")->known_in_a_row == 10);
	assert(strmap_get(&blockmap, "block1-9")->known_in_a_row == 11);

	assert(tal_count(state->longest_knowns) == 1);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "block1-9"));
	assert(tal_count(state->longest_chains) == 1);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "block1-9"));
	assert(state->preferred_chain == strmap_get(&blockmap, "block1-9"));

	/* Now add one we don't know all of. */
	add_next_block(state, strmap_get(&blockmap, "block1-9"),
		       "block1-10", 1, PROTOCOL_INITIAL_SHARD_ORDER, &dummy);
	assert(tal_count(state->longest_knowns) == 1);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "block1-9"));
	assert(tal_count(state->longest_chains) == 1);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "block1-10"));
	assert(state->preferred_chain == strmap_get(&blockmap, "block1-10"));
	assert(strmap_get(&blockmap, "block1-9")->known_in_a_row == 11);
	assert(strmap_get(&blockmap, "block1-10")->known_in_a_row == 0);
	assert(!block_all_known(strmap_get(&blockmap, "block1-10")));

	/* Now add another all-known one to that. */
	add_next_block(state, strmap_get(&blockmap, "block1-10"),
		       "block1-11", 0, PROTOCOL_INITIAL_SHARD_ORDER, &dummy);
	assert(tal_count(state->longest_knowns) == 1);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "block1-9"));
	assert(tal_count(state->longest_chains) == 1);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "block1-11"));
	assert(state->preferred_chain == strmap_get(&blockmap, "block1-11"));
	assert(strmap_get(&blockmap, "block1-9")->known_in_a_row == 11);
	assert(strmap_get(&blockmap, "block1-10")->known_in_a_row == 0);
	assert(strmap_get(&blockmap, "block1-11")->known_in_a_row == 1);

	/* Create a all-known competitor to block1-9. */
	add_next_block(state, strmap_get(&blockmap, "block1-8"),
		       "block2-9", 0, PROTOCOL_INITIAL_SHARD_ORDER, &dummy);
	assert(tal_count(state->longest_knowns) == 2);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "block1-9"));
	assert(state->longest_knowns[1] == strmap_get(&blockmap, "block2-9"));
	assert(tal_count(state->longest_chains) == 1);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "block1-11"));
	assert(state->preferred_chain == strmap_get(&blockmap, "block1-11"));
	assert(strmap_get(&blockmap, "block1-9")->known_in_a_row == 11);
	assert(strmap_get(&blockmap, "block1-10")->known_in_a_row == 0);
	assert(strmap_get(&blockmap, "block1-11")->known_in_a_row == 1);
	assert(strmap_get(&blockmap, "block2-9")->known_in_a_row == 11);

	/* Extend it by one more, and it will become preferred. */
	add_next_block(state, strmap_get(&blockmap, "block2-9"),
		       "block2-10", 0, PROTOCOL_INITIAL_SHARD_ORDER, &dummy);
	assert(tal_count(state->longest_knowns) == 1);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "block2-10"));
	assert(tal_count(state->longest_chains) == 1);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "block1-11"));
	assert(state->preferred_chain == strmap_get(&blockmap, "block2-10"));
	assert(strmap_get(&blockmap, "block1-9")->known_in_a_row == 11);
	assert(strmap_get(&blockmap, "block1-10")->known_in_a_row == 0);
	assert(strmap_get(&blockmap, "block1-11")->known_in_a_row == 1);
	assert(strmap_get(&blockmap, "block2-9")->known_in_a_row == 11);
	assert(strmap_get(&blockmap, "block2-10")->known_in_a_row == 12);

	/* Add tx to shard to complete block1-10. */
	strmap_get(&blockmap, "block1-10")->shard[0]->txcount++;
	update_block_ptrs_new_shard(state, strmap_get(&blockmap, "block1-10"),
				    0);
	assert(tal_count(state->longest_knowns) == 1);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "block1-11"));
	assert(tal_count(state->longest_chains) == 1);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "block1-11"));
	assert(state->preferred_chain == strmap_get(&blockmap, "block1-11"));
	assert(strmap_get(&blockmap, "block1-9")->known_in_a_row == 11);
	assert(strmap_get(&blockmap, "block1-10")->known_in_a_row == 12);
	assert(strmap_get(&blockmap, "block1-11")->known_in_a_row == 13);

	/* But, if block-1-10 is invalidated, we go back... */
	strmap_get(&blockmap, "block1-10")->complaint = "foo";
	strmap_get(&blockmap, "block1-11")->complaint = "foo";
	update_block_ptrs_invalidated(state,
				      strmap_get(&blockmap, "block1-10"));
	
	assert(tal_count(state->longest_knowns) == 1);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "block2-10"));
	assert(tal_count(state->longest_chains) == 1);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "block2-10"));
	assert(state->preferred_chain == strmap_get(&blockmap, "block2-10"));

	/* Now create multiple known chains, and multiple longest
	 * chains. */
	create_chain(state, strmap_get(&blockmap, "block2-10"), "known1",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 5, true);
	create_chain(state, strmap_get(&blockmap, "block2-10"), "known2",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 5, true);
	create_chain(state, strmap_get(&blockmap, "block2-10"), "known3",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 5, true);

	create_chain(state, strmap_get(&blockmap, "block2-10"), "unknown1",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 10, false);
	create_chain(state, strmap_get(&blockmap, "block2-10"), "unknown2",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 10, false);
	create_chain(state, strmap_get(&blockmap, "block2-10"), "unknown3",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 10, false);

	/* Default order must be first in, best dressed. */
	assert(tal_count(state->longest_knowns) == 3);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "known1-4"));
	assert(state->longest_knowns[1] == strmap_get(&blockmap, "known2-4"));
	assert(state->longest_knowns[2] == strmap_get(&blockmap, "known3-4"));
	assert(tal_count(state->longest_chains) == 3);
	assert(state->longest_chains[0] == strmap_get(&blockmap, "unknown1-9"));
	assert(state->longest_chains[1] == strmap_get(&blockmap, "unknown2-9"));
	assert(state->longest_chains[2] == strmap_get(&blockmap, "unknown3-9"));
	assert(state->preferred_chain == strmap_get(&blockmap, "known1-4"));

	/* If we make one of the known chains equal to the longest chains,
	 * it will become preferred. */
	create_chain(state, strmap_get(&blockmap, "known3-4"), "known3-unknown",
		     &dummy, PROTOCOL_INITIAL_SHARD_ORDER, 5, false);
	assert(tal_count(state->longest_knowns) == 3);
	assert(state->longest_knowns[0] == strmap_get(&blockmap, "known3-4"));
	assert(state->longest_knowns[1] == strmap_get(&blockmap, "known2-4"));
	assert(state->longest_knowns[2] == strmap_get(&blockmap, "known1-4"));
	assert(tal_count(state->longest_chains) == 4);
	assert(state->longest_chains[0]
	       == strmap_get(&blockmap, "known3-unknown-4"));
	assert(state->longest_chains[1] == strmap_get(&blockmap, "unknown2-9"));
	assert(state->longest_chains[2] == strmap_get(&blockmap, "unknown3-9"));
	assert(state->longest_chains[3] == strmap_get(&blockmap, "unknown1-9"));
	assert(state->preferred_chain == strmap_get(&blockmap, "known3-unknown-4"));

	strmap_clear(&blockmap);
	tal_free(state);
	return 0;
}
