/* This calculates the genesis block, eg, to base it off bitcoin:
 *
 * # Get 17 bytes of nonce. 
 * NONCE=`wget https://blockchain.info/q/latesthash -q -O- | cut -c48-`
 * # Use current date
 * DATE=`date +%s`
 *
 * ./mkgenesis 0x1effffff $DATE "$NONCE" > genesis.c
 */
#include "hash_block.h"
#include "merkle_hashes.h"
#include "protocol.h"
#include "shadouble.h"
#include "shard.h"
#include "version.h"
#include <assert.h>
#include <ccan/array_size/array_size.h>
#include <ccan/err/err.h>
#include <stdio.h>
#include <stdlib.h>

static void dump_array(const u8 *arr, size_t len)
{
	size_t i;

	printf("{ ");
	for (i = 0; i < len; i++)
		printf("0x%02x%s ", arr[i], i == len - 1 ? "" : ",");
	printf(" }");
}	

int main(int argc, char *argv[])
{
	struct protocol_block_header hdr;
	struct protocol_block_tailer tailer;
	struct protocol_double_sha merkles[1 << PROTOCOL_INITIAL_SHARD_ORDER];
	struct protocol_block_id sha;
	u8 shard_nums[1 << PROTOCOL_INITIAL_SHARD_ORDER];
	unsigned int i;

	err_set_progname(argv[0]);

	if (argc != 4
	    || strlen(argv[3]) != sizeof(hdr.nonce2) + sizeof(tailer.nonce1))
		errx(1, "Usage: mkgenesis difficulty timestamp %zu-byte-nonce",
			sizeof(hdr.nonce2) + sizeof(tailer.nonce1));

	hdr.version = current_version();
	hdr.features_vote = 0;
	hdr.shard_order = PROTOCOL_INITIAL_SHARD_ORDER;
	memcpy(hdr.nonce2, argv[3] + sizeof(tailer.nonce1), sizeof(hdr.nonce2));
	memset(&hdr.prev_block, 0, sizeof(hdr.prev_block));
	hdr.num_prev_txhashes = cpu_to_le32(0);
	hdr.height = cpu_to_le32(0);
	memset(&hdr.fees_to, 0, sizeof(hdr.fees_to));

	for (i = 0; i < num_shards(&hdr); i++)
		shard_nums[i] = 0;

	for (i = 0; i < num_shards(&hdr); i++)
		merkle_hashes(NULL, 0, 0, &merkles[i]);

	tailer.timestamp = cpu_to_le32(strtoul(argv[2], NULL, 0));
	tailer.difficulty = cpu_to_le32(strtoul(argv[1], NULL, 0));
	memcpy(&tailer.nonce1, argv[3], sizeof(tailer.nonce1));

	printf("/* Generated by: mkgenesis %s %s '%s' */\n",
	       argv[1], argv[2], argv[3]);
	printf("#include \"genesis.h\"\n");
	printf("#include \"protocol.h\"\n\n");
	printf("static struct protocol_block_header genesis_hdr = {\n");
	printf("\t.version = %u,\n", hdr.version);
	printf("\t.features_vote = %u,\n", hdr.features_vote);
	printf("\t.shard_order = %u,\n", hdr.shard_order);
	{
		printf("\t.nonce2 = ");
		dump_array(hdr.nonce2, sizeof(hdr.nonce2));
		printf(",\n");
	}
	{
		printf("\t.fees_to = { ");
		dump_array(hdr.fees_to.addr, ARRAY_SIZE(hdr.fees_to.addr));
		printf(" }\n");
	}
	printf("};\n");

	printf("static const struct protocol_block_tailer genesis_tlr = {\n");
	printf("\t.timestamp = CPU_TO_LE32(%u),\n",
	       le32_to_cpu(tailer.timestamp));
	printf("\t.difficulty = CPU_TO_LE32(0x%08x),\n",
	       le32_to_cpu(tailer.difficulty));
	printf("\t.nonce1 = CPU_TO_LE32(%u)\n", le32_to_cpu(tailer.nonce1));
	printf("};\n");

	/* This will be all zeroes, but let's be precise. */
	printf("static const u8 genesis_shardnums[] = {\n");
	for (i = 0; i < num_shards(&hdr); i++)
		printf("%s%u", i == 0 ? "" : ", ", shard_nums[i]);
	printf("\n};\n");

	printf("static const struct protocol_double_sha genesis_merkles[] = {\n");
	for (i = 0; i < num_shards(&hdr); i++) {
		printf("{ ");
		dump_array(merkles[i].sha, ARRAY_SIZE(merkles[i].sha));
		printf("} ,\n");
	}
	printf("};\n");

	for (i = 0; i < num_shards(&hdr); i++) {
		printf("static struct block_shard genesis_shard%i = {\n",
		       i);
		printf("\t.shardnum = %i\n", i);
		/* Rest all zeroes/NULLs. */
		printf("};\n");
	}
	printf("static struct block_shard *genesis_shards[] = {\n");
	for (i = 0; i < num_shards(&hdr); i++)
		printf("%s&genesis_shard%i",
		       i == 0 ? "\t" : ", ", i);
	printf("\n};\n");

	hash_block(&hdr, shard_nums, merkles, NULL, &tailer, &sha.sha);

	printf("struct block genesis = {\n"
	       "	.hdr = &genesis_hdr,\n"
	       "	.shard_nums = genesis_shardnums,\n"
	       "	.merkles = genesis_merkles,\n"
	       "	.tailer = &genesis_tlr,\n"
	       "	.shard = genesis_shards,\n"
	       "	.children = LIST_HEAD_INIT(genesis.children),\n"
	       "	.all_known = true,\n"
	       "	.sha = { { ");

	dump_array(sha.sha.sha, ARRAY_SIZE(sha.sha.sha));
	printf("} }\n};\n");

	return 0;
};
